package org.iplantc.de.server;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.Security;
import java.util.Date;

import javax.crypto.Cipher;

import org.apache.commons.lang.ArrayUtils;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMReader;
import org.bouncycastle.util.encoders.Base64;

/**
 * Used to generate authentication tokens for the foundational API.
 * 
 * @author Dennis Roberts
 */
public class FoundationalApiTokenGenerator {
    /**
     * The encoding of all strings generated by this class.
     */
    private static String ENCODING = "ISO-8859-1";

    /**
     * The key pair used to encrypt the token that is forwarded to the foundational API.
     */
    private KeyPair keyPair;

    /**
     * Initializes a new instance of this class.
     * 
     * @throws IOException if the private key can't be loaded.
     */
    public FoundationalApiTokenGenerator(String keyFile) throws IOException {
        validateKeyFile(keyFile);
        loadPrivateKey(keyFile);
    }

    /**
     * Verifies that the path to the key file is not null.
     * 
     * @param keyFile the path to the file containing the private key.
     * @throws IOException if the path to the key file is null.
     */
    private void validateKeyFile(String keyFile) throws IOException {
        if (keyFile == null) {
            throw new IOException("foundational API key file not specified");
        }
    }

    /**
     * Loads the private key from the key file.
     * 
     * @param keyFile the path to the file containing the private key.
     * @throws IOException if the key can't be loaded.
     */
    private void loadPrivateKey(String keyFile) throws IOException {
        Security.addProvider(new BouncyCastleProvider());
        PEMReader pemReader = new PEMReader(new InputStreamReader(getKeyFileAsStream(keyFile)));
        Object extractedObject = pemReader.readObject();
        if (!(extractedObject instanceof KeyPair)) {
            throw new IOException("foundational API key file does not contain a private key");
        }
        keyPair = (KeyPair)extractedObject;
    }

    /**
     * Gets a reference to the key file as an input stream.
     * 
     * @param keyFile the path to the file containing the private key.
     * @return the reference to the key file.
     * @throws IOException if the key file can't be opened.
     */
    private InputStream getKeyFileAsStream(String keyFile) throws IOException {
        InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(keyFile);
        if (in == null) {
            throw new IOException("unable to open " + keyFile + " for input");
        }
        return in;
    }

    /**
     * Generates an authentication token.
     * 
     * @param username the username to include in the token.
     * @return The token.
     * @throws GeneralSecurityException if the token can't be encrypted.
     */
    public String generateToken(String username) throws GeneralSecurityException {
        String plaintextToken = username + "|" + String.valueOf(new Date().getTime());
        byte[] encrypted = encryptString(plaintextToken);
        byte[] unencoded = ArrayUtils.addAll(getBytes(username + ":"), encrypted);
        return bytesToString(Base64.encode(unencoded));
    }

    /**
     * Encrypts a string.
     * 
     * @param unencrypted the string to encrypt.
     * @return the encrypted string.
     * @throws GeneralSecurityException if the string can't be encrypted.
     */
    private byte[] encryptString(String unencrypted) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(keyPair.getPrivate().getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());
        byte[] encrypted = cipher.doFinal(getBytes(unencrypted));
        return Base64.encode(encrypted);
    }

    /**
     * Decrypts an authentication token.
     * 
     * @param token the token to decrypt.
     * @return the decrypted token.
     * @throws GeneralSecurityException if the token can't be decrypted.
     */
    public String decryptToken(String token) throws GeneralSecurityException {
        byte[] decoded = Base64.decode(token);
        int encryptedStart = ArrayUtils.indexOf(decoded, charToByte(':')) + 1;
        byte[] encrypted = ArrayUtils.subarray(decoded, encryptedStart, decoded.length);
        return decryptString(encrypted);
    }

    /**
     * Decrypts a string.
     * 
     * @param encrypted the encrypted string.
     * @return The decrypted string.
     * @throws GeneralSecurityException if the string can't be decrypted.
     */
    private String decryptString(byte[] encrypted) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(keyPair.getPublic().getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPublic());
        byte[] decrypted = cipher.doFinal(Base64.decode(encrypted));
        return bytesToString(decrypted);
    }

    /**
     * Converts a character to a byte.
     * 
     * @param c the character to convert.
     * @return the byte.
     * @throws IllegalArgumentException if the character is translated to more than one byte.
     */
    private byte charToByte(char c) throws IllegalArgumentException {
        char[] chars = {c};
        byte[] bytes = getBytes(new String(chars));
        if (bytes.length > 1) {
            throw new IllegalArgumentException("unable to convert character, " + c
                    + ", to a single byte");
        }
        return bytes[0];
    }

    /**
     * Gets the bytes used to form the given string in the appropriate encoding.
     * 
     * @param str the string to convert.
     * @return the byte array.
     */
    private byte[] getBytes(String str) {
        try {
            return str.getBytes(ENCODING);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Converts a byte array in the appropriate encoding to a string.
     * 
     * @param bytes the array of bytes.
     * @return the string.
     */
    private String bytesToString(byte[] bytes) {
        try {
            return new String(bytes, ENCODING);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
}
